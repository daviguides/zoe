package com.interfactus.zoe.controls.media.oldVideoClasses{	import com.interfactus.zoe.controls.media.videoClasses.VideoAlign;	import com.interfactus.zoe.controls.media.videoClasses.VideoScaleMode;	import com.interfactus.zoe.controls.media.VideoState;		import flash.display.Sprite;	import flash.external.ExternalInterface;	import flash.geom.ColorTransform;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.utils.clearInterval;	import flash.utils.setInterval;
		class FAVideo extends Sprite	{		// Constants:		private static var EI_ERROR:String = 'eiError';				// Private Properties:		private var _source:String;		private var _skinAutoHide:Boolean;		private var _autoPlay:Boolean;		private var _totalTime:Number;		private var _state:String;		private var _videoScaleMode:String;		private var _videoAlign:String;		private var _themeColor:Number;		private var _playheadUpdateInterval:Number;		private var _playheadUpdateInt:Number;		private var _flvWidth:Number;		private var _flvHeight:Number;		private var _skinVisible:Boolean;		private var __width:Number;		private var __height:Number;		private var _autoLoad:Boolean = true;		private var _previewImagePath:String;		private var _inited:Boolean;		private var _pauseAfterSeek:Boolean;		private var initialVideoPath:String = "";		private var flvHeightOffset:Number = 0; //Used when the skin is under the flv file.		private var playerID:String;		private var currentState:Object;		private var jsPropMap:Object;		private var lastSentPlayheadTime:Number;		private var clickToTogglePlayDelegate:Function;		private var _clickToTogglePlay:Boolean;		private var audioControl:SoundChannel;		private var loadingDelegate:Function;		private var netConn:NetConnection;		private var netStream:NetStream;		private var lastBytesLoaded:Number;				// UI Elements:		private var video:Video;				// Initialization:		private function onLoad():void { configUI(); }				// Public Methods:		public function get volume():Number { return audioControl.volume; }		public function set volume(volume:Number):Number { setVolume(volume); }				public function get state():String { return _state; }		public function get totalTime():Number { return _totalTime; }		public function get playheadTime():Number { return netStream.time; }		public function get contentPath():String { return _source; }				/*public function get width():Number { return x + __width; }		public function get height():Number { return y + (__height-flvHeightOffset); }*/				public function get bytesLoaded():Number { return netStream.bytesLoaded; }		public function get bytesTotal():Number { return netStream.bytesTotal; }				public function seekPercent(value:Number):void {			if (value < 0 || value > 100 || totalTime == undefined || totalTime <= 0) { return; }			seek(totalTime * value / 100);		}				private function sendEvent(param0:String):void
		{
			// TODO Auto Generated method stub
			
		}				public function _scrubFinish():void {			// do nothing.		}				public function _scrubStart():void {			// do nothing.		}		// END Interface for the UIManager						public function playVideo(source:String, totalTime:Number):void {			initialVideoPath = "";						_source = (source == null) ? _source : source;			_totalTime = (totalTime == undefined) ? _totalTime : totalTime;						setAutoPlay(true);						if (_source == source && _state == VideoState.PAUSED || _state == VideoState.STOPPED) {				pause(false);			} else {				load();			}		}				public function loadVideo(source:String, totalTime:Number):void {			initialVideoPath = "";						_source = source;			_totalTime = totalTime;			setAutoPlay(false);						load();		}				public function pause(value:Boolean):void {			if (value == null) {				value = VideoState.PAUSED?false:true;			}			if (!Boolean(value) && initialVideoPath != "") {				playVideo(initialVideoPath);			} else if (value) {				netStream.pause(true);				setState(VideoState.PAUSED);			} else {				netStream.pause(false);				setState(VideoState.PLAYING);				previewImage.visible =  false;				setPlayheadUpdateInterval(_playheadUpdateInterval);				trackLoading();			}		}				public function stop():void {			seek(0);			pause(true);			dispatchEvent({type:'playheadUpdate', playheadTime:0, totalTime:_totalTime}); //Event for the UIManager			setState(VideoState.STOPPED);		}				public function seek(seekToSeconds:Number):void {			setState(VideoState.SEEKING);						if (seekToSeconds < 0) {				seek(0);				_pauseAfterSeek = true;			} else  if (seekToSeconds > totalTime) {				seek(totalTime);				_pauseAfterSeek = true;			} else {				netStream.seek(seekToSeconds);			}		}				// Private Methods:		private function initConnection():Boolean {			if (netConn && netStream) { return true; }						if (!netConn) { netConn = new NetConnection(); }						var canConnect:Boolean = netConn.connect(null);						if (!canConnect) { return false; }						if (!netStream) {				netStream = new NetStream(netConn);								netStream.onCuePoint = Delegate.create(this, onNetStreamCuePoint);				netStream.onMetaData = Delegate.create(this, onNetStreamMetaData);				netStream.onStatus = Delegate.create(this, onNetStreamStatus);			}						video.attachVideo(netStream);			this.attachAudio(netStream);			audioControl = new Sound(this);						return true;		}				private function load():void {			if (!_source) { return; }			if (initConnection()) {				netStream.play(_source);				trackLoading();				setState(VideoState.LOADING);			} else {				setState(VideoState.CONNECTION_ERROR);			}		}				private function setAutoLoad(value:Boolean):void {			_autoLoad = value;		}				private function onLoading(event:Object):void {			if (lastBytesLoaded == bytesLoaded) { return; } 						if (bytesLoaded > 4 && bytesLoaded == bytesTotal) {				ticker.removeEventListener('tick', loadingDelegate);			}						lastBytesLoaded = bytesLoaded;						sendEvent('progress', {bytesLoaded:bytesLoaded, bytesTotal:bytesTotal});			dispatchEvent({type:'progress', bytesLoaded:bytesLoaded, bytesTotal:bytesTotal}); //Event for the UIManager		}				private function onNetStreamStatus(infoObject:Object):void {			switch (infoObject.code) {				case 'NetStream.Buffer.Empty':					setState(VideoState.BUFFERING);					break;				case 'NetStream.Buffer.Full':					setState(VideoState.PLAYING);					//pause(false);					break;				case 'NetStream.Buffer.Flush':					break;				case 'NetStream.Play.Start':										if (!_autoPlay) {						pause(true);						dispatchEvent({type:'ready'}); //Event for the UIManager						sendEvent('ready');					} else {						setPlayheadUpdateInterval(_playheadUpdateInterval || 250);						setState(VideoState.PLAYING);					}					break;				case 'NetStream.Play.StreamNotFound':					setState(VideoState.CONNECTION_ERROR);					ticker.removeEventListener('tick', loadingDelegate);					break;				case 'NetStream.Seek.InvalidTime':				case 'NetStream.Seek.Notify':					sendEvent('status', infoObject);					if (state == VideoState.STOPPED || _pauseAfterSeek) {						delete _pauseAfterSeek;						netStream.pause(true);					} else {						netStream.pause(false);					}					break;				case 'NetStream.Play.Stop':					setState(VideoState.STOPPED);					sendEvent('complete');					stop();					break;				default:			}		}				private function onNetStreamMetaData(metaData:Object):void {			if (metaData.duration && !_totalTime) {				setTotalTime(metaData.duration);			}						if (metaData.width && metaData.width) {				_flvWidth = metaData.width;				_flvHeight = metaData.height;			}						sendEvent('metaData', metaData);			dispatchEvent({type:'metadataReceived'}); //Event for the UIManager		}				private function onNetStreamCuePoint(cuePoint:Object):void {			sendEvent('cuePoint', cuePoint);		}				/**		 * @private		 * 		 */		private function setState(state:String):void {			_state = state;			dispatchEvent({type:'stateChange', state:_state}); //Event for the UIManager						switch (state) {				case EI_ERROR:					enableInterface(false);					eiError._visible = true;					break;				case VideoState.PAUSED:					sendEvent('stateChange', {state:VideoState.PAUSED});					break;				case VideoState.PLAYING:					sendEvent('stateChange', {state:VideoState.PLAYING});					break;				case VideoState.STOPPED:					sendEvent('stateChange', {state:VideoState.STOPPED});					break;				case VideoState.BUFFERING:					sendEvent('stateChange', {state:VideoState.BUFFERING});					break;				case VideoState.LOADING:					sendEvent('stateChange', {state:VideoState.LOADING});					break;				case VideoState.SEEKING:					sendEvent('stateChange', {state:VideoState.SEEKING});					break;				case VideoState.CONNECTION_ERROR:					sendEvent('stateChange', {state:VideoState.CONNECTION_ERROR});					halt();					break;				case VideoState.DISCONNECTED:					sendEvent('stateChange', {state:VideoState.DISCONNECTED});					halt();					break;				default:			}		}				private function halt():void {			removePlayheadUpdateInt();			ticker.removeEventListener('tick', loadingDelegate);		}				/**		 * Possible Values are: "maintainAspectRatio", "noScale", and "exactFit"		 * 		 * @default maintainAspectRatio		 */		private function onResize():void {			switch (_videoScaleMode) {				case VideoScaleMode.NO_SCALE:					video._width = video.width;					video._height = video.height;					break;				case VideoScaleMode.MAINTAIN_ASPECT_RATIO:					sizeVideo(true);					break;				case VideoScaleMode.EXACT_FIT:					sizeVideo(false);					break;			}						var newWidth = __width;			var newHeight = __height - flvHeightOffset;						//Posistion Video			switch (_videoAlign) {				case VideoAlign.BOTTOM:					video.y =  newHeight - video.height;					video.x = (newWidth - video.width) / 2;					break;				case VideoAlign.BOTTOMLEFT:					video.y =  Stage.height - video.height;					video.x = 0;					break;				case VideoAlign.BOTTOMRIGHT:					video.y =  newHeight - video.height;					video.x = newWidth - video.width;					break;				case VideoAlign.TOP:					video.y = 0;					video.x = (newWidth - video.width)/2;					break;				case VideoAlign.TOPLEFT:					video.y = video.x = 0;					break;				case VideoAlign.TOPRIGHT:					video.y = 0;					video.x = newWidth - video.width;					break;				case VideoAlign.CENTER:					video.y =  (newHeight - video.height)/2;					video.x = (newWidth - video.width)/2;					break;				case VideoAlign.LEFT:					video.y =  (newHeight - video.height)/2;					video.x = 0;					break;				case VideoAlign.RIGHT:					video.y = (newHeight - video.height)/2;					video.x = newWidth - video.width;					break;				default:			}						dispatchEvent({type:'resize', x:video.x, y:video.y, width:width, height:width}); //Event for the UIManager		}				private function sizeVideo(maintainAspectRatio:Boolean):void {			var w:Number = __width;			var h:Number = __height - flvHeightOffset;						var vidWidth:Number = !video || video.width==0?__width:video.width;			var vidHeight:Number = !video || video.height==0?__height:video.height;						if (maintainAspectRatio) { // Find best fit.				var containerRatio:Number = w / h;				var imageRatio:Number = vidWidth / vidHeight;								if (containerRatio < imageRatio) {					h = w / imageRatio;				} else {					w = h * imageRatio;				}			}						video.width = w;			video.height = h;		}				private function togglePlay():void {			pause(_state == VideoState.PLAYING);		}				private function configUI():void {			_videoScaleMode = VideoScaleMode.MAINTAIN_ASPECT_RATIO;			_videoAlign = VideoAlign.CENTER;		}				private function removePlayheadUpdateInt():void {			clearInterval(_playheadUpdateInt);			delete _playheadUpdateInt;		}				// START JS interface methods.		// All of these methods are called (indirectly via callMethod) from the FAVideo object in Javascript.				/**		 * @private		 * 		 * @deafult = false		 * 		 * Allows the user to click anywhere on the video to play/pause.		 * 		 */		private function setClickToTogglePlay(value:Boolean):void {			_clickToTogglePlay = value;		}				/**		 * @private		 * 		 * @default = true		 */		private function setAutoPlay(value:Boolean):void {			_autoPlay = value;		}				/**		 * @private		 * 		 * @default = 1		 */		private function setVolume(value:Number):void {			audioControl.setVolume(value);			dispatchEvent({type:'volumeUpdate', volume:value}); //Event for the UIManager		}				/**		 * @private		 * 		 */		private function setTotalTime(value:Number):void {			_totalTime = value;		}				/**		 * @private		 * 		 */		private function setPlayheadTime(value:Number):void {			seek(value);		}				/**		 * @private		 * 		 * @default = 250		 * 		 * A number that is the amount of time, in milliseconds, between each playheadUpdate event.		 */		private function setPlayheadUpdateInterval(value:Number):void {			_playheadUpdateInterval = value;						removePlayheadUpdateInt();			if (netStream) {				_playheadUpdateInt = setInterval(this, 'sendPlayheadUpdate', _playheadUpdateInterval);			}		}			}}